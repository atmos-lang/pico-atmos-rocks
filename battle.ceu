export [METEOR-MS,SHIP-SHOTS] { ;; CONSTANTS
    val METEOR-MS  = 5000   ;; average period to spawn a new meteor
    val SHIP-SHOTS = 3      ;; maximum number of simultaneous shots
}

export [Move-T] {           ;; DATA :T
    data :T = [rect:Rect] {
        ;;;
        ;; Describes the data hierarchy :T for the public fields of objects:
        ;;  - They all expose a :Rect object for collision detection.
        ;;  - We distinguish between objects on the left and right (:L and :R).
        ;;;
        :Ship = [] {
            :L = []
            :R = []
        }
        :Shot = [] {
            :L = []
            :R = []
        }
        :Meteor = []
    }

    task Move-T (rect:Rect, vel:XY) {
        ;;;
        ;; Updates the given `rect` position according to its `vel` speed.
        ;;  - Updates on every :Frame.
        ;;  - Terminates when leaving the screen.
        ;;;
        awaiting out-of-screen() {
            every :Pico.Frame {
                val dt = evt.ms / 1000
                set rect.pos.x = rect.pos.x + (vel.x * dt)
                set rect.pos.y = rect.pos.y + (vel.y * dt)
            }
        } where {
            func out-of-screen () {
                ifs {
                    rect.pos.x < -(WIN.w/2) -> true
                    rect.pos.x >  (WIN.w/2) -> true
                    rect.pos.y < -(WIN.h/2) -> true
                    rect.pos.y >  (WIN.h/2) -> true
                    else -> false
                }
            }
        }
    }
}

export [meteors,shots,ships,Meteor] {
    ^["ts.ceu"] ;; includes the object tasks

    val t = [           ;; holds all spawned shots, limited to a maximum
        tasks(),  ;;  - shots for ship in the right
        tasks(),  ;;  - shots for ship in the right
    ]

    ;;;
    ;; Declares and spawns the game objects:
    ;;  - Meteors live in a dynamic pool of tasks and are spawned periodically.
    ;;  - Ships are fixed and held in a tuple pair.
    ;;  - Shots live in dynamic pools, one for each ship, which are held in a
    ;;    tuple pair.
    ;; Pools control the lifecycle of tasks by releasing them from memory
    ;; automatically on termination. Tasks in pools are anonymous and can only
    ;; be accessed through iterators or reference tracks.
    ;;;

    val meteors = tasks()   ;; holds all spawned meteors

    val shots = [           ;; holds all spawned shots, limited to a maximum
        tasks(SHIP-SHOTS),  ;;  - shots for ship in the left
        tasks(SHIP-SHOTS),  ;;  - shots for ship in the right
    ]

    val ships = [           ;; holds the two ships
        spawn Ship(:T.Ship.L, pos.0, ctl.0, shots.0, "imgs/ship-L.gif"),
        spawn Ship(:T.Ship.R, pos.1, ctl.1, shots.1, "imgs/ship-R.gif"),
    ] where {
        val pos = [         ;; positions for each ship
            [(-WIN.w/2)+(WIN.w/10), 0], ;; left  of the screen
            [( WIN.w/2)-(WIN.w/10), 0], ;; right of the screen
        ]
        val ctl = [         ;; key controls for each ship
            [[:Key-A,    :Key-D,     :Key-W,  :Key-S],    :Key-Shift-Left],
            [[:Key-Left, :Key-Right, :Key-Up, :Key-Down], :Key-Shift-Right],
        ]
    }
}

awaiting (evt==ships.0) or (evt==ships.1) {     ;; GAMEPLAY
    ;;;
    ;; Runs the gameplay until one of the two ships is destroyed:
    ;;  - Spawns new meteors periodically.
    ;;  - Checks collisions between all objects.
    ;;;
    par {                   ;; METEORS
        ;;;
        ;; Spawns new meteros in the game every period:
        ;;  - Hold them in the outer pool.
        ;;  - Gradually decreases the spawning period.
        ;;;
        var period = METEOR-MS;
        every (random-next() % period) :ms {
            set period = max(50, period - 10)
            spawn in meteors, Meteor()
        }
    } with {
        every :Pico.Frame { ;; COLLISIONS
            ;;;
            ;; Checks collisions between objects:
            ;;  1. Uses `to-tracks` to collect the ships and all (safe)
            ;;     references to dinamically allocated meteors and shots.
            ;;  2. Uses `pico-collisions` to get all pairs of colliding
            ;;     objects, using the `f-cmp` comparator which relies on `:T`
            ;;     rect.
            ;;  3. Iterates over the pairs, ignores innocuous collisions, and
            ;;     collects final colliding objects.
            ;;  4. Signals colliding objects.
            ;; A ship collision will eventually terminate the enclosing
            ;; `awaiting`, also terminating the current battle.
            ;;;
            val trks =      ;; (1)
                to-tracks(ships.0, ships.1, shots.0, shots.1, meteors)

            val pairs =     ;; (2)
                pico-collisions(trks,f-cmp) where {
                    func f-cmp (p1:T, p2:T) {
                        pico-rect-vs-rect?(p1.rect, p2.rect)
                    }
                }

            val fins = #[] ;; (3)
            loop in iter(pairs), ts {
                val col? = do {
                    val t0 = detrack(ts.0).pub
                    val t1 = detrack(ts.1).pub
                    ifs {
                        (t0 is? :T.Ship.R) and (t1 is? :T.Shot.R) -> false
                        (t0 is? :T.Shot.R) and (t1 is? :T.Ship.R) -> false
                        (t0 is? :T.Ship.L) and (t1 is? :T.Shot.L) -> false
                        (t0 is? :T.Shot.L) and (t1 is? :T.Ship.L) -> false
                        (t0 is? :T.Meteor) and (t1 is? :T.Meteor) -> false
                        else -> true
                    }
                }
                if col? {
                    set fins[+] = ts.0
                    set fins[+] = ts.1
                }
            }

            loop in iter(fins), j { ;; (4)
                broadcast in detrack(j), :collided
            }
        }
    }
}

ifs {                       ;; BATTLE RESULT
    ;;;
    ;; Returns the winner index to the main game loop:
    ;;  - 1, if ship.0 is dead
    ;;  - 0, if ship.1 is dead
    ;;;
    (status(ships[0]) == :terminated) -> 1
    (status(ships[1]) == :terminated) -> 0
    else -> throw(:error)
}
