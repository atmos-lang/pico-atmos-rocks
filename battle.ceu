do :unnest {                ;; CONSTANTS
    val METEOR-MS  = 5000   ;; period to spawn a new meteor
    val SHIP-SHOTS = 3      ;; maximum number of simultaneous shots
}

do :unnest {                ;; DATA :T
    data :T = [rect:Rect] {
        :Ship = [] {
            :L = []
            :R = []
        }
        :Shot = [] {
            :L = []
            :R = []
        }
        :Meteor = []
    }

    task Move-T (rect:Rect, vel:XY) {
        awaiting out-of-screen() {
            every :Pico.Frame {
                val dt = evt.ms / 1000
                set rect.pos.x = rect.pos.x + (vel.x * dt)
                set rect.pos.y = rect.pos.y + (vel.y * dt)
            }
        } where {
            func out-of-screen () {
                ifs {
                    rect.pos.x < -(WIN.w/2) -> true
                    rect.pos.x >  (WIN.w/2) -> true
                    rect.pos.y < -(WIN.h/2) -> true
                    rect.pos.y >  (WIN.h/2) -> true
                    else -> false
                }
            }
        }
    }
}

do :unnest {                ;; METEORS, SHIPS, SHOTS
    ^["ts.ceu"]

    ;;;
    ;; - All dynamically spawned meteors, bonuses, and bombs reside in 
    ;;   this pool.
    ;;;
    val meteors = tasks()

    ;;;
    ;; - Creates the two ships.
    ;; They differ in ids (:ship-1 vs :ship-2), initial positions,
    ;; screen limits, key controllers, and image orientations
    ;; (i.e., pointing :R or :L).
    ;;;

    val shots = [tasks(SHIP-SHOTS), tasks(SHIP-SHOTS)]

    val ships = [
        spawn Ship(:L, pos.0, ctl.0, shots.0, "imgs/ship-L.gif"),
        spawn Ship(:R, pos.1, ctl.1, shots.1, "imgs/ship-R.gif"),
    ] where {
        val pos = [
            [(-WIN.w/2)+(WIN.w/10), 0],
            [( WIN.w/2)-(WIN.w/10), 0],
        ]
        val ctl = [
            [[:Key-A,    :Key-D,     :Key-W,  :Key-S],    :Key-Shift-Left],
            [[:Key-Left, :Key-Right, :Key-Up, :Key-Down], :Key-Shift-Right],
        ]
    }
}

;;;
;; - The game innermost "awaiting" terminates when either of the two
;;   ships is destroyed.
;; - We then proceed to increment the points before restarting the
;;   outer loop for the next battle.
;;;

awaiting (evt==ships.0) or (evt==ships.1) {
    ;;;
    ;; - Spawns new meteros in the game.
    ;; It starts with 2s but goes down continuously.
    ;; The "spawn" creates a dynamic instance of "Rock-Big".
    ;; All instances are limited to the closest outer "do-end" 
    ;; block (in this case, the "battle block").
    ;; When the block terminates, all instances are automatically 
    ;; destroyed, i.e., when one of the ships is destroyed, the 
    ;; "battle block" will restart and all meteors will be 
    ;; automatically destroyed.
    ;;;
    spawn {
        var period = METEOR-MS;
        every (random-next() % period) :ms {
            set period = max(50, period - 10)
            spawn in meteors, Meteor()
        }
    }

    func f-cmp (p1:T, p2:T) {
        pico-rect-vs-rect?(p1.rect, p2.rect)
    }

    ;;;
    ;; - Collision detection loop:
    ;;  - "$objs" is the number of alive objects.
    ;;  - "objs"  contains references to them.
    ;; We iterate over "objs" to check for collisions between "o1" 
    ;; vs "o2" for every possible pairs of objects.
    ;; Then, we check each "id" in the collisions to take the 
    ;; proper action.
    ;;;
    every :Pico.Frame {
        val trks = to-tracks(shots.0, shots.1, ships.0, ships.1, meteors)
        val cols = pico-collisions(f-cmp, trks)
        val cols' = @[]
        loop in iter(cols), i {
            val col? = do {
                val t0 = detrack(i.1.0).pub
                val t1 = detrack(i.1.1).pub
                ifs {
                    (t0 is :T.Ship.R) and (t1 is :T.Shot.R) -> false
                    (t0 is :T.Shot.R) and (t1 is :T.Ship.R) -> false
                    (t0 is :T.Ship.L) and (t1 is :T.Shot.L) -> false
                    (t0 is :T.Shot.L) and (t1 is :T.Ship.L) -> false
                    (t0 is :T.Meteor)   and (t1 is :T.Meteor)   -> false
                    else -> true
                }
            }
            if col? {
                set cols'[i.1.0] = true
                set cols'[i.1.1] = true
            }
        }
        loop in iter(cols'), j {
            broadcast in detrack(j.0), :collided
        }
    }
}
ifs {
    (ships[0].status == :terminated) -> 1
    (ships[1].status == :terminated) -> 0
    else -> throw(:error)
}
