require "ts" ;; task prototypes for Ship, Shot, Meteor

;; Left/Right ship constant parameters

val V = @{
    l = @{                          ;; left ship
        tag = 'L',
        pos = PP(10, 50),           ;; x,y initial position
        ctl = @{                    ;; key controls
            move  = { l='A', r='D', u='W', d='S'},
            frame = { l=0, r=1, u=2, d=3 },
            shot  = 'Left Shift',
        },
        lim = { x1=0, x2=W/2 },     ;; x limits (half of screen)
        shot = { tag='l', x=1 },    ;; shot tag, x direction
        img = "imgs/ship-L.gif",    ;; ship image
    },
    r = @{
        tag = 'R',
        pos = PP(90, 50),
        ctl = @{
            move = @{ l='Left', r='Right', u='Up', d='Down' },
            frame = @{ l=1, r=0, u=2, d=3 },
            shot = 'Right Shift',
        },
        lim = @{ x1=W/2, x2=W },
        shot = @{ tag='r', x=-1 },
        img = "imgs/ship-R.gif",    ;; ship image
    },
}

;;;
;; Declares and spawns the game objects:
;;  - Meteors live in a dynamic pool of tasks and are spawned periodically.
;;  - Ships are fixed and held in a tuple pair.
;;  - Shots live in dynamic pools, one for each ship, which are held in a
;;    tuple pair.
;; Pools control the lifecycle of tasks by releasing them from memory
;; automatically on termination. Tasks in pools are anonymous and can only
;; be accessed through iterators or reference tracks.
;;;

func Battle () {
    pin meteors = tasks()   ;; holds all spawned meteors

    val shots = [           ;; holds all spawned shots (max of 3 simultaneous)
        tasks(3),           ;;  - shots for ship in the left
        tasks(3),           ;;  - shots for ship in the right
    ]

        val pos = [         ;; positions for each ship
            0.1 || 0.5,     ;; left  of the screen
            0.9 || 0.5,     ;; right of the screen
        ]
        val ctl = [         ;; key controls for each ship
            [[:Key-A,    :Key-D,     :Key-W,  :Key-S],    :Key-Shift-Left],
            [[:Key-Left, :Key-Right, :Key-Up, :Key-Down], :Key-Shift-Right],
        ]

    val ships = [           ;; holds the two ships
        spawn Ship(:T.Ship.L, pos[0], ctl[0], shots[0], "imgs/ship-L.gif"),
        spawn Ship(:T.Ship.R, pos[1], ctl[1], shots[1], "imgs/ship-R.gif"),
    ] ;;where { }

    watching |((it==ships[0]) or (it==ships[1])) {     ;; GAMEPLAY
        ;;;
        ;; Runs the gameplay until one of the two ships is destroyed:
        ;;  - Spawns new meteors periodically.
        ;;  - Checks collisions between all objects.
        ;;;
        par {                   ;; METEORS
            ;;;
            ;; Spawns new meteros in the game every period:
            ;;  - Hold them in the outer pool.
            ;;  - Gradually decreases the spawning period.
            ;;;
            var period = 5000   ;; average period to spawn a new meteor
            loop {
                val dt = random.int(1, period)
                await <dt:ms>
                spawn Meteor() in meteors
            }
        } with {
            every :Pico.Frame { ;; COLLISIONS
                ;;;
                ;; Checks collisions between objects:
                ;;  1. Uses `to.vector` to collect all references to dinamically
                ;;     allocated ships, shots, and meteors.
                ;;  2. Uses `pico-collisions` to get all pairs of colliding
                ;;     objects, using the `f-cmp` comparator which relies on `:T`
                ;;     rect.
                ;;  3. Iterates over the pairs, ignores innocuous collisions, and
                ;;     collects final colliding objects.
                ;;  4. Signals colliding objects.
                ;; A ship collision will eventually terminate the enclosing
                ;; `watching`, also terminating the current battle.
                ;;;

                val tsks =      ;; (1)
                    to.vector(ships)    <++
                    to.vector(shots[0]) <++
                    to.vector(shots[1]) <++
                    to.vector(meteors)

                val pairs =     ;; (2)
                    pico.collisions(tsks,f-cmp) where {
                        func f-cmp (p1:T, p2:T) {
                            pico.rect-vs-rect?(p1.rect, p2.rect)
                        }
                    }

                val fins = #[] ;; (3)
                loop ts in pairs {
                    val col? = do {
                        val t0 = ts[0].pub
                        val t1 = ts[1].pub
                        ifs {
                            (t0 is? :T.Ship.R) and (t1 is? :T.Shot.R) => false
                            (t0 is? :T.Shot.R) and (t1 is? :T.Ship.R) => false
                            (t0 is? :T.Ship.L) and (t1 is? :T.Shot.L) => false
                            (t0 is? :T.Shot.L) and (t1 is? :T.Ship.L) => false
                            (t0 is? :T.Meteor) and (t1 is? :T.Meteor) => false
                            else => true
                        }
                    }
                    if col? {
                        set fins[+] = ts[0]
                        set fins[+] = ts[1]
                    }
                    until col?
                }

                loop j in fins { ;; (4)
                    broadcast(:collided) in j
                }
            }
        }
    }

    match :terminated {       ;; BATTLE RESULT
        ;;;
        ;; Returns the winner index to the main game loop:
        ;;  - 1, if ship[0] is dead
        ;;  - 0, if ship[1] is dead
        ;;;
        == status(ships[0]) => 1
        == status(ships[1]) => 0
        else => error(:error)
    }
}
