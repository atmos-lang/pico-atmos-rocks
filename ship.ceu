val ACC-DIV     = 10
val SHIP-FRAMES = 4
val SHIP-FIRES  = 3
val FIRE-DIM    = [WIN.w/50, WIN.h/100]
val FIRE-COLOR  = [0xFF,0xFF,0x88,0xFF]
val VEL-MAX :XY = [WIN.w/2.5, WIN.h/2.5]

data :LRUD = [left,right,up,down]
data :Control = [mov:LRUD, fire]

func between (min_max, v) {
    max(min_max.0, min(min_max.1, v))
}

task Fire (side, pos:XY, vy) :T {
    pico-output-sound("snds/fire.wav")
    set task.pub = tags([[pos, FIRE-DIM]], tag, true) where {
        val tag = ((side == :L) and :T.Fire.L) or :T.Fire.R
    }
    par-or {
        await :collided
    } with {
        val sig = ((side==:L) and 1) or -1
        await spawn Move-T(task.pub.rect, [(WIN.w/3)*sig, vy])
    } with {
        every :Pico.Draw {
            pico-state-set-color-draw(FIRE-COLOR)
            pico-output-draw-rect(task.pub.rect)
        }
    }
}

task Ship (side, pos:XY, ctl:Control, fires, path) :T {
    val dim:WH = pico-state-get-size-image(path)
    val vel:XY = [0,0]
    val dy = dim.h / SHIP-FRAMES
    set task.pub = tags([[pos, [dim.w,dy]]], tag, true) where {
        val tag = ((side == :L) and :T.Ship.L) or :T.Ship.R
    }

    ;; Control
    var acc:XY = [0,0]
    var key
    spawn {
        par {
            every :Pico.Key.Dn {
                ifs evt.key {
                    == ctl.mov.left  -> set acc.x = -WIN.w/ACC-DIV
                    == ctl.mov.right -> set acc.x =  WIN.w/ACC-DIV
                    == ctl.mov.up    -> set acc.y =  WIN.h/ACC-DIV
                    == ctl.mov.down  -> set acc.y = -WIN.h/ACC-DIV
                    == ctl.fire      -> spawn in fires, Fire(side, copy(pos), vel.y)
                }
                set key = evt.key
            }
        } with {
            every :Pico.Key.Up {
                set key = nil
                set acc = [0,0]
            }
        }
    }

    par-or {
        await :collided
    } with {
        every :Pico.Draw {
            pico-state-set-image-crop([[0,frame*dy],[dim.w,dy]])
                where {
                    val frame = ifs key {
                        == ctl.mov.left  -> ((side==:L) and 0) or 1
                        == ctl.mov.right -> ((side==:R) and 0) or 1
                        == ctl.mov.up    -> 2
                        == ctl.mov.down  -> 3
                        else -> 0
                    }
                }
            pico-output-draw-image(pos, path)
        }
    } with {
        every :Pico.Frame {
            val dt = evt.ms / 1000
            set vel.x = between([-VEL-MAX.x,VEL-MAX.x], vel.x+(acc.x*dt))
            set vel.y = between([-VEL-MAX.y,VEL-MAX.y], vel.y+(acc.y*dt))
            set pos.x = if side==:L {
                            between([(-WIN.w/2)+dim.w, 0-dim.w], pos.x+(vel.x*dt))
                        } else {
                            between([0+dim.w,  (WIN.w/2)-dim.w], pos.x+(vel.x*dt))
                        }
            set pos.y = between([(-WIN.h/2)+dy, (WIN.h/2)-dy], pos.y+(vel.y*dt))
        }
    }

    ;; explode 40w/s
    pico-output-sound("snds/explosion.wav")
    awaiting 150:ms {
        var d = dy / 2;
        par {
            every :Pico.Frame {
                set d = d + (((40*d)*evt.ms)/1000)
            }
        } with {
            every :Pico.Draw {
                pico-state-set-color-draw([0xFF,0x00,0x00,0xFF])
                pico-output-draw-oval([pos,[d,d]])
            }
        }
    }
}
