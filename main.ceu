^["pico.ceu"]

pico_state_set_title("The Rocks! Game")
pico_state_set_size_pixel(1,1)
pico_state_set_size(641,481)
pico_state_set_grid(false)
pico_state_set_auto(false)

var win = pico_state_get_size()

pico_state_set_font("tiny.ttf", win.1/15)

var ROCK_MS = 500

spawn {
    ;;;
    ;; - Spawn a task to draw the background image on every frame.
    ;; We draw at position (0,0), which is the center of the screen, in which
    ;; the center of the image is drawn.
    ;; Given that this task is the first to appear in the source code, the
    ;; background image will always be rendered first.
    ;;;
    every :draw {
        pico_state_set_image_crop()
        pico_output_draw_image(0,0, "imgs/bg.png")
    }
}

do :unnest {
    ;;;
    ;; Instantiate the players' points (points1, points2) and place them
    ;; at the bottom of the screen, in opposite sides (points1, points2):
    ;;      +------------------------+
    ;;      |                        |
    ;;      |                        |
    ;;      | points1        points2 |
    ;;      +------------------------+
    ;; Each player's points is incremented when the ship of the opponent is 
    ;; destroyed.
    ;; The points outlive each individual battle, so it is placed here,
    ;; outside the nested gameplay.
    ;; Note that a `group` block does not create a new nested scope, which is
    ;; useful to group declarations that remain visible outside.
    ;;;

    var points1 = "0"
    var points2 = "0"

    ;;;
    ;; We spawn the points exhibition so that it coexists with the gameplay.
    ;; Since it is spawned first, the points will be rendered first, such
    ;; they may be covered by moving objects in the gameplay, as desired.
    ;;;
    spawn {
        var dx = win.0 / 15
        var x1 = (-win.0 / 2) + dx
        var x2 = ( win.0 / 2) - dx
        var y  = (-win.1 /2 ) + (win.1 / 15)
        every :draw {
            pico_output_draw_text(x1, y, points1)
            pico_output_draw_text(x2, y, points2)
        }
    }
}

spawn {
    ;;;
    ;; - The "main loop" with the gameplay.
    ;; It is restarted whenever one of the ships is destroyed.
    ;; As the points do not reset between iterations, they need to be defined 
    ;; before entering the loop.
    ;;;

    while true {
        ;;;
        ;; - Shows the centered and blinking "= TAP TO START =" message,
        ;;   and awaits the user interaction.
        ;;;
;;
        awaiting :keydown {
            while true {
                await 500ms
                awaiting 500ms {
                    every :draw {
                        pico_output_draw_text(0, 0, "= TAP TO START =")
                    }
                }
            }
        }
;;

        ;; TODO: sound

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;; - The "battle block" with the gameplay holds the spaceships,
        ;;   controllers, and all dynamic objects, such as meteors, bonuses,
        ;;   and ship shots.
        ;; This means that they are all properly released/reallocated after
        ;; each individual battle.
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;
        ;; - Creates the two ships.
        ;; They differ in ids (:ship1 vs :ship2), initial positions,
        ;; screen limits, key controllers, and image orientations
        ;; (i.e., pointing :right or :left).
        ;;;
		do :unnest {
            ^["ship.ceu"]
            var ship1 = spawn Ship(:ship1, "imgs/ship1.gif", :right, pos1, ctrl1)
                where {
                    var pos1 = [(-win.0/2)+(win.0/10), 0]
                    var ctrl1 = spawn Control(mov1) where {
                                    var mov1 = @[
                                        left  = :Key.A,
                                        right = :Key.D,
                                        up    = :Key.W,
                                        down  = :Key.S,
                                    ]
                                }
                }
            ;;`SDLK_z`, ;;`SDLK_x`, ;;`SDLK_c`, ;;`SDLK_1`,
            ;;`SDLK_SEMICOLON`, ;;`SDLK_PERIOD`, ;;`SDLK_COMMA`, ;;`SDLK_0`,
            var ship2 = spawn Ship(:ship2, "imgs/ship2.gif", :left,  pos2, ctrl2)
                where {
                    var pos2 = [( win.0/2)-(win.0/10), 0]
                    var ctrl2 = spawn Control(mov2) where {
                                    var mov2 = @[
                                        left  = :Key.Left,
                                        right = :Key.Right,
                                        up    = :Key.Up,
                                        down  = :Key.Down,
                                    ]
                                }
                }
        }

        ;;;
        ;; - All dynamically spawned meteors, bonuses, and bombs reside in 
        ;;   this pool.
        ;;;
        var objs = coroutines()

        ;;;
        ;; - The game innermost "awaiting" terminates when either of the two
        ;;   ships is destroyed.
        ;; - We then proceed to increment the points before restarting the
        ;;   outer loop for the next battle.
        ;;;
        awaiting (evt==ship1) or (evt==ship2) {
            ;;;
            ;; - Spawns new meteros in the game.
            ;; It starts with 2s but goes down continuously.
            ;; The "spawn" creates a dynamic instance of "RockBig".
            ;; All instances are limited to the closest outer "do-end" 
            ;; block (in this case, the "battle block").
            ;; When the block terminates, all instances are automatically 
            ;; destroyed, i.e., when one of the ships is destroyed, the 
            ;; "battle block" will restart and all meteors will be 
            ;; automatically destroyed.
            ;;;
            spawn {
                var period = ROCK_MS;
                ;;every (`:number rand()` % period)ms
                every 500ms {
                    set period = max(50, period-10)
                    ;;spawn in objs, ROCK()
                }
            }
            await false
        }
        ifs {
            (ship1.status == :terminated) -> set points2 = tostring(tonumber(points2)+1)
            (ship2.status == :terminated) -> set points1 = tostring(tonumber(points1)+1)
        }
        await 1s
    }
}

pico_loop ()

;;;;
                with
                    /*
                     * Collision detection loop:
                     *      - "$objs" is the number of alive objects.
                     *      - "objs"  contains references to them.
                     * We iterate over "objs" to check for collisions between "o1" 
                     * vs "o2" for every possible pairs of objects.
                     * Then, we check each "id" in the collisions to take the 
                     * proper action.
                     */
                    every SDL_DT do

                        /*
                         * Prepare the vector "objs" with all alive objects.
                         */
                        var Object&&?[_OBJ_NN] objs = [&&ship1, &&ship2];
                        loop o in ship1.fires do
                            objs = [] .. objs .. [o];
                        end
                        loop o in ship2.fires do
                            objs = [] .. objs .. [o];
                        end
                        loop o in all do
                            if o:can_hit then
                                objs = [] .. objs .. [o];
                            end
                        end

                        /*
                         * Outer loop: "o1" iterates through [0, $objs[
                         */
                        loop/_OBJ_NN i in $objs do
                            var Object&&? o1 = objs[i];
                            if not o1? then
                                continue;
                            end

                            /*
                             * Impossible to emit "o1:go_hit" and "o2:go_hit" 
                             * in sequence without one aborting the other due 
                             * to the protecting "watching".
                             * We must set this flag to "emit o1:go_hit" after 
                             * "watching *o2" terminates.
                            */
                            var bool hit1 = false;

                            /*
                             * Inner loop: "o2" iterates through [nxt, $objs[
                             * "nxt" is the index for the next object after "o1".
                             * These two loops make all possible combinations for 
                             * any two objects alive.
                             */
                            loop/_OBJ_NN j in $objs-i-1 do
                                var Object&&? o2 = objs[i+1+j];
                                if not o2? then
                                    continue;
                                end

                                /*
                                 * Take the two current positions and calculate 
                                 * their surrounding rectangles.
                                 * The positions are centered, hence the need to 
                                 * decrement half of w,h to find their respective 
                                 * rectangles.
                                 */
                                var SDL_Rect r1 = o1!:rect;
                                    r1.x = r1.x - r1.w/2;
                                    r1.y = r1.y - r1.h/2;
                                var SDL_Rect r2 = o2!:rect;
                                    r2.x = r2.x - r2.w/2;
                                    r2.y = r2.y - r2.h/2;

                                /*
                                 * Check if the two rectangles have an 
                                 * intersection.
                                 * (Otherwise, go to the next pair of objects).
                                 */
                                if not _SDL_HasIntersection((_SDL_Rect&&)&&r1, (_SDL_Rect&&)&&r2) then
                                    continue;
                                end

                                /*
                                 * "o1" and "o2" collide, now, based on their "id" 
                                 * fields, take the proper actions.
                                 */

                                /*
                                 * We use "getVS(id,...)" to make "oo1" point to 
                                 * the object matching "id" and "oo2" to the other 
                                 * one.
                                 */

                                /*
                                 *  Play sound effects for some collisions:
                                 *  FIRE vs ROCKS/BONUSES: play _SND_ROCK
                                 *  SHIP vs BONUSES:       play _SND_BONUS
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_FIRE1, &&oo1, &&oo2) or
                                       getVS(_OBJ_FIRE2, &&oo1, &&oo2) then
                                        if (oo2:id >= _OBJ_ROCK) and
                                           (oo2:id <= _OBJ_BONUS_FIRE) then
                                            _Mix_PlayChannel(-1, _SND_ROCK, 0);
                                        end
                                    else/if getVS(_OBJ_SHIP1, &&oo1, &&oo2) or
                                            getVS(_OBJ_SHIP2, &&oo1, &&oo2) then
                                        if (oo2:id >= _OBJ_BONUS_LIFE) and
                                           (oo2:id <= _OBJ_BONUS_FIRE) then
                                            _Mix_PlayChannel(-1, _SND_BONUS, 0);
                                        end
                                    end
                                end

                                /*
                                 * FIRE vs ROCKS: spawn random items.
                                 *  - 35%: spawn 2 small rocks
                                 *  -  5%: spawn (+1, life)
                                 *  - 15%: spawn (H, hit point)
                                 *  - 15%: spawn (S, shield)
                                 *  - 15%: spawn (F, fire width)
                                 *  - 15%: spawn (B, bomb)
                                 * Here we only spawn the items.
                                 * (All items that should be destroyed in 
                                 * collisions are handled together below, after 
                                 * handling extra effects.)
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_ROCK, &&oo1, &&oo2) and
                                       (oo2:id==_OBJ_FIRE1 or oo2:id==_OBJ_FIRE2) then
                                        var int dir;    // which direction to spawn?
                                        if oo2:id == _OBJ_FIRE1 then
                                            dir =  1;   // left  if shot by FIRE1
                                        else
                                            dir = -1;   // right if shot by FIRE2
                                        end
                                        var int pct = _rand() % 100;
                                        if pct < 35 then
                                            /*
                                             * Spawn two smaller rocks.
                                             * They go in the opposite direction of the 
                                             * ship that hit the rock.
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                            var int x = (int) oo2:rect.x;
                                            var int y = (int) oo2:rect.y;
                                            loop ii in 2 do
                                                spawn RockSmall in all with
                                                    this.rect = SDL_Rect(x,y,0,0);
                                                    this.dir  = dir;
                                                end;
                                            end

                                            /*
                                             * Spawn bonuses.
                                             * They go in the same direction of the 
                                             * ship that hit the rock.
                                             * They differ in "id" and "tex".
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                        else/if pct < 40 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_LIFE;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_LIFE);
                                                this.dir  = -dir;
                                            end;
                                        else/if pct < 55 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_HITS;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_HITS);
                                                this.dir  = -dir;
                                            end;
                                        else/if pct < 70 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id     = _OBJ_BONUS_SHIELD;
                                                this.tex    = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_SHIELD);
                                                this.dir    = -dir;
                                            end;
                                        else/if pct < 85 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_FIRE;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_FIRE);
                                                this.dir  = -dir;
                                            end;
                                        else
                                            /*
                                             * Spawn a bomb.
                                             * It goes in the opposite direction of the 
                                             * ship that hit the rock.
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                            spawn Bomb in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.dir  = dir;
                                            end;
                                        end
                                    end
                                end

                                /*
                                 * SHIP vs BONUS_LIFE (+1):
                                 * Increment the player's total points.
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_LIFE, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 then
                                            emit points1.go_inc;
                                        else/if oo2:id == _OBJ_SHIP2 then
                                            emit points2.go_inc;
                                        end
                                    end
                                end

                                /*
                                 * SHIP vs BONUS_LIFE (+1):
                                 * Increment the player's total points.
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_HITS, &&oo1, &&oo2) then
                                        if (oo2:id == _OBJ_SHIP1) or
                                           (oo2:id == _OBJ_SHIP2) then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_H;
                                        end
                                    end
                                end

                                // BonusShield vs Ship: go_S
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_SHIELD, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 or
                                           oo2:id == _OBJ_SHIP2 then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_S;
                                        end
                                    end
                                end

                                // BonusFire vs Ship: fire.rect.w++
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_FIRE, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 or
                                           oo2:id == _OBJ_SHIP2 then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_F;
                                        end
                                    end
                                end

                                /*
                                 * Signal the two items that they were hit.
                                 * For ROCKS, BONUSES, FIRE, and BOMB, this will 
                                 * make them terminate their execution. Given that 
                                 * they were instantiated with "spawn", this will 
                                 * also make them be freed by the system.
                                 * For SHIP, this will make them loose a hit point.
                                 * (More details in "objs.ceu".)
                                 */
                                var int id1 = o1!:id;
                                var int id2 = o2!:id;
                                if _idVSid[id2][id1] then
                                    hit1 = true; /* delay emit */
                                    emit o1!:go_hit;     // only emit if _idVSid()
                                end
                                if _idVSid[id1][id2] then
                                    emit o2!:go_hit;     // only emit if _idVSid()
                                end
                                if not o1? then
                                    break;
                                end
                                /*
                                 * Note that the "emit go_hit" must happen after 
                                 * the previous effects, because it may release the 
                                 * object from the memory.
                                 */
                            end // o2 iteration
                        end // o1 iteration
                        /*
                         * Finished comparing all objects alive.
                         * Wait for the next frame.
                         */
                    end // coolision detection loop
                end // game innermost "par/or"
                /*
                 * One of the ships was destroyed (ship.ok_killed).
                 * The innermost "par/or" terminated.
                 */
            end // the "battle block"
            /*
             * The "battle block" terminated, the ships, controllers, and all 
             * dynamic items are destroyed.
             * Restart the "main loop" and show the "= TAP TO START =" message 
             * again.
             * The points are kept (they are declated in the outer scope).
             */
        end // the "main loop"
        /*
         * The "main loop" never terminates.
         * This "end" is never surpassed.
         */
    #ifdef DEBUG_FPS
    with
        /*
         * If we are in DEBUG mode (defined in "Makefile"), we display a text with 
         * the current frame rate of the game.
         * We count the number of times we react to the "SDL_REDRAW" event in one 
         * second.
         */
        var int fps = 0;                // previous FPS
        loop do
            var int c = 0;              // reset the current counter

            // create a texture with the previous FPS
            var char[5] str;
            _sprintf(str, "%d", fps);
            var _SDL_Texture&? tex;
            var SDL_Color white = SDL_COLOR_WHITE;
            finalize
                tex = &_SDL_text2texture(_REN, _FONT_SMALL, str,
                                         (_SDL_Color&&)&&white, null);
            with
                _SDL_DestroyTexture(&&tex!);
            end
            var SDL_Rect r = (200,200, 30,30);

            /*
             * During 1 second, show the previous FPS and increment the current 
             * counter "c" on every frame.
             * After 1 second, set "fps" to the current "c" and restart the 
             * process.
             */
            watching 1s do
                every SDL_REDRAW do
                    c = c + 1;
                    _SDL_RenderCopy(_REN, &&tex, null, (_SDL_Rect&&)&&r);
                end
            end
            fps = c;
            //_printf("[FPS=%d]\n", fps);
        end
    #endif
    with
        /*
         * Complete the drawing process for every frame.
         * Given that this trail is the last to appear in the source code (among 
         * those that react to "SDL_REDRAW"), it will only take effect after all 
         * objects are redrawn.
         */
        every SDL_REDRAW do
            _SDL_RenderPresent(_REN);
        end
    #ifndef CEU_TIMEMACHINE
    #if defined(SIMULATION) || defined(SIMULATION_TEST)
    with
        #include "input.ceu"
        do Input with
            this.visible = false;
        end;
    #endif
    #endif

    /* TODO:
     * - PAUSE/IF salva img emostra pause em cima
     * - BONUS_ACCEL
     * - MENU: control-sides, reset-points
     * - start at 1/2 speed of previous match
     */
    }
}
;;;;
