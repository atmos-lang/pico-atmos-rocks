^["pico.ceu"]

pico_state_set_title("The Rocks! Game")
pico_state_set_size_pixel(1,1)
pico_state_set_size(641,481)
pico_state_set_grid(false)
pico_state_set_auto(false)

var win = pico_state_get_size()

pico_state_set_font("tiny.ttf", win.1/15)


spawn {
    par {
        ;;;
         ; - Draw the background image on every frame.
         ; We draw at position (0,0), which is the center of the screen, in which
         ; the center of the image is drawn.
         ; Given that this trail is the first to appear in the source code, the
         ; background image will always be rendered first.
        ;;;
        every :draw {
            pico_output_draw_image(0,0, "imgs/bg.png")
        }
    } with {
        await false
    } with {
        ;; The "main trail" is where all game action takes place.

        ;;;
         ; Instantiate the players' points (points1, points2) and place them
         ; at the bottom of the screen, in opposite sides (p1, p2):
         ;      +------------------------+
         ;      |                        |
         ;      |                        |
         ;      | p1                  p2 |
         ;      +------------------------+
         ; Each player's points is incremented when the ship of the opponent is 
         ; destroyed.
         ; The points outlive each individual battle, so it is placed here,
         ; outside the nested gameplay.
        ;;;

        var p1 = "0"
        var p2 = "0"

        ;; We spawn the points exhibition so that it coexists with the gameplay.
        ;; Since it is spawned first, the points will be rendered first, such
        ;; they may be covered by moving objects in the gameplay, as desired.
        spawn {
            var dx = win.0 / 15
            var x1 = (-win.0 / 2) + dx
            var x2 = ( win.0 / 2) - dx
            var y  = (-win.1 /2 ) + (win.1 / 15)
            every :draw {
                pico_output_draw_text(x1, y, p1)
                pico_output_draw_text(x2, y, p2)
            }
        }

        ;;;
         ; - The "main loop" with the gameplay.
         ; It is restarted whenever one of the ships is destroyed.
         ; As the points do not reset between iterations, they need to be defined 
         ; before entering the loop.
        ;;;

        while true {
            ;;;
             ; - Shows the centered and blinking "= TAP TO START =" message,
             ;   and awaits the user interaction.
            ;;;
;;;
            awaiting :keydown {
                while true {
                    await 500ms
                    awaiting 500ms {
                        every :draw {
                            pico_output_draw_text(0, 0, "= TAP TO START =")
                        }
                    }
                }
            }
;;;

            ;; TODO: sound

            ;;;
             ; - The "battle block" with the gameplay holds the spaceships,
             ;   controllers, and all dynamic objects, such as meteors,
             ;   bonuses, and ship shots.
             ; This means that they are all properly released/reallocated
             ; after each individual battle.
            ;;;
            do {
                ;;;
                 ; - Creates the two ships.
                 ; They differ in ids (:ship1 vs :ship2), initial positions,
                 ; screen limits, key controllers, and image orientations
                 ; (i.e., pointing :right or :left).
                ;;;

                ^["ship.ceu"]
                var pos1 = [(-win.0/2)+(win.0/10), 0]
                var ship1 = spawn Ship(:ship1, "imgs/ship1.gif", :right, pos1, [], [])
                var pos2 = [( win.0/2)-(win.0/10), 0]
                var ship2 = spawn Ship(:ship2, "imgs/ship2.gif", :left,  pos2, [], [])
                await false
            }
        }
;;;;

                var ship1 = (spawn Ship(:ship1, "imgs/ship1.gif", :right, pos, lims, ctrl))
                    where {
                        var pos = [-win.0/2, 0]
                        var lims = [
                            [], []
                        ]
                        var ctrl = [
                            `:number SDLK_w`,
                            `:number SDLK_s`,
                            `:number SDLK_a`,
                            `:number SDLK_d`,
                            `:number SDLK_z`,
                            `:number SDLK_x`,
                            `:number SDLK_c`,
                            `:number SDLK_1`,
                        ]
                    }

                var ship2 = (spawn Ship(:ship2, "imgs/ship2.gif", :left, pos, ctrl))
                    where {
                        var pos = [ win.0/2, 0]
                        var lims = [
                            [], []
                        ]
                        var ctrl = [
                            `:number SDLK_UP`,
                            `:number SDLK_DOWN`,
                            `:number SDLK_LEFT`,
                            `:number SDLK_RIGHT`,
                            `:number SDLK_SEMICOLON`,
                            `:number SDLK_PERIOD`,
                            `:number SDLK_COMMA`,
                            `:number SDLK_0`,
                        ]
                    }
            }
        }
            do

                var int dim=0; // ship dimensions are squared (WxW):
                    _SDL_QueryTexture(_TEX_SHIP1, null, null, &&dim, null);

                var Ship ship1 with
                    this.tex    = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_SHIP1);
                    this.rect   = SDL_Rect(dim,_REN_H/2,0,0); // w/h set inside

                end;

                var Ship ship2 with
                    this.tex    = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_SHIP2);
                    this.rect   = SDL_Rect(_REN_W-dim,_REN_H/2,0,0); // w/h set inside
                end;

                /*
                 * All dynamically spawned meteors, bonuses, and bombs reside in 
                 * this pool.
                 */
                pool NObject[_OBJ_N] all;
                    /* TODO: read "NObject" this as a synonym for "Object" */

                /*
                 * The game innermost "par/or" only terminates when one of the 
                 * ships is destroyed. It is responsible for spawning new meteors 
                 * and checking collisions on every frame.
                 */
                par/or do
                    await ship1.ok_killed;      // if ship1 is destroyed,
                    emit points2.go_inc;        //  increment points2
                with
                    await ship2.ok_killed;      // if ship2 is destroyed,
                    emit points1.go_inc;        //  increment points1
                with
                    /*
                     * Period to create a new meteor in the game.
                     * It starts with 2s but goes down continuously.
                     * The "spawn" creates a dynamic instance of "RockBig".
                     * All instances are limited to the closest outer "do-end" 
                     * block (in this case, the "battle block").
                     * When the block terminates, all instances are automatically 
                     * destroyed, i.e., when one of the ships is destroyed, the 
                     * "battle block" will restart and all meteors will be 
                     * automatically destroyed.
                     */
                    var int period = _ROCKS_MS;
                    every (_rand() % period)ms do
                        if period > 50 then
                            period = period - 10;
                        end
                        spawn RockBig in all with
                            this.rect = SDL_Rect(0,0,0,0);  // all set inside
                        end;
                    end
                with
                    /*
                     * Collision detection loop:
                     *      - "$objs" is the number of alive objects.
                     *      - "objs"  contains references to them.
                     * We iterate over "objs" to check for collisions between "o1" 
                     * vs "o2" for every possible pairs of objects.
                     * Then, we check each "id" in the collisions to take the 
                     * proper action.
                     */
                    every SDL_DT do

                        /*
                         * Prepare the vector "objs" with all alive objects.
                         */
                        var Object&&?[_OBJ_NN] objs = [&&ship1, &&ship2];
                        loop o in ship1.fires do
                            objs = [] .. objs .. [o];
                        end
                        loop o in ship2.fires do
                            objs = [] .. objs .. [o];
                        end
                        loop o in all do
                            if o:can_hit then
                                objs = [] .. objs .. [o];
                            end
                        end

                        /*
                         * Outer loop: "o1" iterates through [0, $objs[
                         */
                        loop/_OBJ_NN i in $objs do
                            var Object&&? o1 = objs[i];
                            if not o1? then
                                continue;
                            end

                            /*
                             * Impossible to emit "o1:go_hit" and "o2:go_hit" 
                             * in sequence without one aborting the other due 
                             * to the protecting "watching".
                             * We must set this flag to "emit o1:go_hit" after 
                             * "watching *o2" terminates.
                            */
                            var bool hit1 = false;

                            /*
                             * Inner loop: "o2" iterates through [nxt, $objs[
                             * "nxt" is the index for the next object after "o1".
                             * These two loops make all possible combinations for 
                             * any two objects alive.
                             */
                            loop/_OBJ_NN j in $objs-i-1 do
                                var Object&&? o2 = objs[i+1+j];
                                if not o2? then
                                    continue;
                                end

                                /*
                                 * Take the two current positions and calculate 
                                 * their surrounding rectangles.
                                 * The positions are centered, hence the need to 
                                 * decrement half of w,h to find their respective 
                                 * rectangles.
                                 */
                                var SDL_Rect r1 = o1!:rect;
                                    r1.x = r1.x - r1.w/2;
                                    r1.y = r1.y - r1.h/2;
                                var SDL_Rect r2 = o2!:rect;
                                    r2.x = r2.x - r2.w/2;
                                    r2.y = r2.y - r2.h/2;

                                /*
                                 * Check if the two rectangles have an 
                                 * intersection.
                                 * (Otherwise, go to the next pair of objects).
                                 */
                                if not _SDL_HasIntersection((_SDL_Rect&&)&&r1, (_SDL_Rect&&)&&r2) then
                                    continue;
                                end

                                /*
                                 * "o1" and "o2" collide, now, based on their "id" 
                                 * fields, take the proper actions.
                                 */

                                /*
                                 * We use "getVS(id,...)" to make "oo1" point to 
                                 * the object matching "id" and "oo2" to the other 
                                 * one.
                                 */

                                /*
                                 *  Play sound effects for some collisions:
                                 *  FIRE vs ROCKS/BONUSES: play _SND_ROCK
                                 *  SHIP vs BONUSES:       play _SND_BONUS
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_FIRE1, &&oo1, &&oo2) or
                                       getVS(_OBJ_FIRE2, &&oo1, &&oo2) then
                                        if (oo2:id >= _OBJ_ROCK) and
                                           (oo2:id <= _OBJ_BONUS_FIRE) then
                                            _Mix_PlayChannel(-1, _SND_ROCK, 0);
                                        end
                                    else/if getVS(_OBJ_SHIP1, &&oo1, &&oo2) or
                                            getVS(_OBJ_SHIP2, &&oo1, &&oo2) then
                                        if (oo2:id >= _OBJ_BONUS_LIFE) and
                                           (oo2:id <= _OBJ_BONUS_FIRE) then
                                            _Mix_PlayChannel(-1, _SND_BONUS, 0);
                                        end
                                    end
                                end

                                /*
                                 * FIRE vs ROCKS: spawn random items.
                                 *  - 35%: spawn 2 small rocks
                                 *  -  5%: spawn (+1, life)
                                 *  - 15%: spawn (H, hit point)
                                 *  - 15%: spawn (S, shield)
                                 *  - 15%: spawn (F, fire width)
                                 *  - 15%: spawn (B, bomb)
                                 * Here we only spawn the items.
                                 * (All items that should be destroyed in 
                                 * collisions are handled together below, after 
                                 * handling extra effects.)
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_ROCK, &&oo1, &&oo2) and
                                       (oo2:id==_OBJ_FIRE1 or oo2:id==_OBJ_FIRE2) then
                                        var int dir;    // which direction to spawn?
                                        if oo2:id == _OBJ_FIRE1 then
                                            dir =  1;   // left  if shot by FIRE1
                                        else
                                            dir = -1;   // right if shot by FIRE2
                                        end
                                        var int pct = _rand() % 100;
                                        if pct < 35 then
                                            /*
                                             * Spawn two smaller rocks.
                                             * They go in the opposite direction of the 
                                             * ship that hit the rock.
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                            var int x = (int) oo2:rect.x;
                                            var int y = (int) oo2:rect.y;
                                            loop ii in 2 do
                                                spawn RockSmall in all with
                                                    this.rect = SDL_Rect(x,y,0,0);
                                                    this.dir  = dir;
                                                end;
                                            end

                                            /*
                                             * Spawn bonuses.
                                             * They go in the same direction of the 
                                             * ship that hit the rock.
                                             * They differ in "id" and "tex".
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                        else/if pct < 40 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_LIFE;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_LIFE);
                                                this.dir  = -dir;
                                            end;
                                        else/if pct < 55 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_HITS;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_HITS);
                                                this.dir  = -dir;
                                            end;
                                        else/if pct < 70 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id     = _OBJ_BONUS_SHIELD;
                                                this.tex    = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_SHIELD);
                                                this.dir    = -dir;
                                            end;
                                        else/if pct < 85 then
                                            spawn Bonus in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.id   = _OBJ_BONUS_FIRE;
                                                this.tex  = &_UNSAFE_POINTER_TO_REFERENCE(_TEX_BONUS_FIRE);
                                                this.dir  = -dir;
                                            end;
                                        else
                                            /*
                                             * Spawn a bomb.
                                             * It goes in the opposite direction of the 
                                             * ship that hit the rock.
                                             * (All instances are also scoped to the 
                                             * "battle block".)
                                             */
                                            spawn Bomb in all with
                                                this.rect = SDL_Rect(oo2:rect.x,
                                                                     oo2:rect.y,
                                                                     0,0);
                                                this.dir  = dir;
                                            end;
                                        end
                                    end
                                end

                                /*
                                 * SHIP vs BONUS_LIFE (+1):
                                 * Increment the player's total points.
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_LIFE, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 then
                                            emit points1.go_inc;
                                        else/if oo2:id == _OBJ_SHIP2 then
                                            emit points2.go_inc;
                                        end
                                    end
                                end

                                /*
                                 * SHIP vs BONUS_LIFE (+1):
                                 * Increment the player's total points.
                                 */
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_HITS, &&oo1, &&oo2) then
                                        if (oo2:id == _OBJ_SHIP1) or
                                           (oo2:id == _OBJ_SHIP2) then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_H;
                                        end
                                    end
                                end

                                // BonusShield vs Ship: go_S
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_SHIELD, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 or
                                           oo2:id == _OBJ_SHIP2 then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_S;
                                        end
                                    end
                                end

                                // BonusFire vs Ship: fire.rect.w++
                                do
                                    var Object&& oo1 = o1!;
                                    var Object&& oo2 = o2!;
                                    if getVS(_OBJ_BONUS_FIRE, &&oo1, &&oo2) then
                                        if oo2:id == _OBJ_SHIP1 or
                                           oo2:id == _OBJ_SHIP2 then
                                            var Ship&& ship = (Ship&&) oo2;
                                            emit ship:go_F;
                                        end
                                    end
                                end

                                /*
                                 * Signal the two items that they were hit.
                                 * For ROCKS, BONUSES, FIRE, and BOMB, this will 
                                 * make them terminate their execution. Given that 
                                 * they were instantiated with "spawn", this will 
                                 * also make them be freed by the system.
                                 * For SHIP, this will make them loose a hit point.
                                 * (More details in "objs.ceu".)
                                 */
                                var int id1 = o1!:id;
                                var int id2 = o2!:id;
                                if _idVSid[id2][id1] then
                                    hit1 = true; /* delay emit */
                                    emit o1!:go_hit;     // only emit if _idVSid()
                                end
                                if _idVSid[id1][id2] then
                                    emit o2!:go_hit;     // only emit if _idVSid()
                                end
                                if not o1? then
                                    break;
                                end
                                /*
                                 * Note that the "emit go_hit" must happen after 
                                 * the previous effects, because it may release the 
                                 * object from the memory.
                                 */
                            end // o2 iteration
                        end // o1 iteration
                        /*
                         * Finished comparing all objects alive.
                         * Wait for the next frame.
                         */
                    end // coolision detection loop
                end // game innermost "par/or"
                /*
                 * One of the ships was destroyed (ship.ok_killed).
                 * The innermost "par/or" terminated.
                 */
            end // the "battle block"
            /*
             * The "battle block" terminated, the ships, controllers, and all 
             * dynamic items are destroyed.
             * Restart the "main loop" and show the "= TAP TO START =" message 
             * again.
             * The points are kept (they are declated in the outer scope).
             */
        end // the "main loop"
        /*
         * The "main loop" never terminates.
         * This "end" is never surpassed.
         */
    #ifdef DEBUG_FPS
    with
        /*
         * If we are in DEBUG mode (defined in "Makefile"), we display a text with 
         * the current frame rate of the game.
         * We count the number of times we react to the "SDL_REDRAW" event in one 
         * second.
         */
        var int fps = 0;                // previous FPS
        loop do
            var int c = 0;              // reset the current counter

            // create a texture with the previous FPS
            var char[5] str;
            _sprintf(str, "%d", fps);
            var _SDL_Texture&? tex;
            var SDL_Color white = SDL_COLOR_WHITE;
            finalize
                tex = &_SDL_text2texture(_REN, _FONT_SMALL, str,
                                         (_SDL_Color&&)&&white, null);
            with
                _SDL_DestroyTexture(&&tex!);
            end
            var SDL_Rect r = (200,200, 30,30);

            /*
             * During 1 second, show the previous FPS and increment the current 
             * counter "c" on every frame.
             * After 1 second, set "fps" to the current "c" and restart the 
             * process.
             */
            watching 1s do
                every SDL_REDRAW do
                    c = c + 1;
                    _SDL_RenderCopy(_REN, &&tex, null, (_SDL_Rect&&)&&r);
                end
            end
            fps = c;
            //_printf("[FPS=%d]\n", fps);
        end
    #endif
    with
        /*
         * Complete the drawing process for every frame.
         * Given that this trail is the last to appear in the source code (among 
         * those that react to "SDL_REDRAW"), it will only take effect after all 
         * objects are redrawn.
         */
        every SDL_REDRAW do
            _SDL_RenderPresent(_REN);
        end
    #ifndef CEU_TIMEMACHINE
    #if defined(SIMULATION) || defined(SIMULATION_TEST)
    with
        #include "input.ceu"
        do Input with
            this.visible = false;
        end;
    #endif
    #endif

    /* TODO:
     * - PAUSE/IF salva img emostra pause em cima
     * - BONUS_ACCEL
     * - MENU: control-sides, reset-points
     * - start at 1/2 speed of previous match
     */
;;;;
    }
}

pico_loop ()
